package com.swe.canvas.datamodel.serialization;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.swe.canvas.datamodel.action.Action;
import com.swe.canvas.datamodel.action.ActionType;
import com.swe.canvas.datamodel.action.CreateShapeAction;
import com.swe.canvas.datamodel.action.DeleteShapeAction;
import com.swe.canvas.datamodel.action.ModifyShapeAction;
import com.swe.canvas.datamodel.action.ResurrectShapeAction;
import com.swe.canvas.datamodel.canvas.ShapeState;
import com.swe.canvas.datamodel.shape.EllipseShape;
import com.swe.canvas.datamodel.shape.FreehandShape;
import com.swe.canvas.datamodel.shape.LineShape;
import com.swe.canvas.datamodel.shape.Point;
import com.swe.canvas.datamodel.shape.RectangleShape;
import com.swe.canvas.datamodel.shape.Shape;
import com.swe.canvas.datamodel.shape.ShapeId;
import com.swe.canvas.datamodel.shape.ShapeType;
import com.swe.canvas.datamodel.shape.TriangleShape;

/**
 * Provides manual JSON serialization and deserialization for the Canvas data model
 * (Shapes and Actions) using only core Java classes (no external libraries like Gson/Jackson).
 * This class uses StringBuilder for manual JSON construction and simple regex/string
 * manipulation for manual JSON parsing.
 *
 * <p>NOTE: This manual parser is highly fragile and relies on the exact output format
 * generated by the manual serializer.</p>
 */
public final class ManualSerializer {

    private ManualSerializer() {
        // Utility class
    }

    // =========================================================================
    // Core Helpers
    // =========================================================================

    /**
     * Converts a java.awt.Color to an ARGB hex string (e.g., "#FF000000").
     */
    private static String colorToHex(final Color color) {
        if (color == null) {
            return "#00000000";
        }
        // Color.getRGB() returns int in 0xAARRGGBB format
        return String.format("#%08X", color.getRGB());
    }

    /**
     * Converts an ARGB hex string to a java.awt.Color.
     */
    private static Color hexToColor(final String hexString) {
        if (hexString == null || hexString.length() != 9 || !hexString.startsWith("#")) {
            return Color.BLACK;
        }
        try {
            // Long.parseLong handles the parsing, using 'true' for alpha
            return new Color((int) Long.parseLong(hexString.substring(1), 16), true);
        } catch (NumberFormatException e) {
            return Color.BLACK;
        }
    }

    /**
     * Helper to wrap a string value in quotes and escape internal quotes (if any).
     * @param value The value to wrap.
     * @return The quoted, escaped string.
     */
    private static String jsonEscape(final String value) {
        if (value == null) {
            return "null";
        }
        return "\"" + value.replace("\"", "\\\"") + "\"";
    }

    // =========================================================================
    // Shape Serialization/Deserialization
    // =========================================================================

    /**
     * Manually serializes a ShapeState object into a JSON string, matching the C# IShape format.
     * @param shapeState The shape state to serialize.
     * @return A JSON string.
     */
    public static String serializeShape(final ShapeState shapeState) {
        if (shapeState == null || shapeState.getShape() == null) {
            return null;
        }

        final Shape shape = shapeState.getShape();
        final StringBuilder sb = new StringBuilder();

        sb.append("{");
        
        // 1. ShapeId
        sb.append(jsonEscape("ShapeId")).append(":").append(jsonEscape(shape.getShapeId().getValue())).append(",");
        
        // 2. Type
        sb.append(jsonEscape("Type")).append(":").append(jsonEscape(shape.getShapeType().toString())).append(",");

        // 3. Points Array
        sb.append(jsonEscape("Points")).append(":[");
        final List<Point> points = shape.getPoints();
        for (int i = 0; i < points.size(); i++) {
            final Point p = points.get(i);
            sb.append("{");
            sb.append(jsonEscape("X")).append(":").append(p.getX()).append(",");
            sb.append(jsonEscape("Y")).append(":").append(p.getY());
            sb.append("}");
            if (i < points.size() - 1) {
                sb.append(",");
            }
        }
        sb.append("],");

        // 4. Color
        sb.append(jsonEscape("Color")).append(":").append(jsonEscape(colorToHex(shape.getColor()))).append(",");
        
        // 5. Thickness
        sb.append(jsonEscape("Thickness")).append(":").append(shape.getThickness()).append(",");

        // 6. CreatedBy
        sb.append(jsonEscape("CreatedBy")).append(":").append(jsonEscape(shape.getCreatedBy())).append(",");
        
        // 7. LastModifiedBy
        sb.append(jsonEscape("LastModifiedBy")).append(":").append(jsonEscape(shape.getLastUpdatedBy())).append(",");
        
        // 8. IsDeleted
        sb.append(jsonEscape("IsDeleted")).append(":").append(shapeState.isDeleted());
        
        // Removed: "$type" and "LastModified" fields to match C# output.

        sb.append("}");
        return sb.toString();
    }

    /**
     * Manually deserializes a JSON string back into a ShapeState object.
     * @param json The JSON string.
     * @return The ShapeState object.
     */
    public static ShapeState deserializeShape(final String json) {
        if (json == null || json.isEmpty() || "null".equals(json)) {
            return null;
        }

        // Extremely fragile manual parsing using regex and string splitting.
        // This relies on the exact format produced by serializeShape.
        try {
            final String content = json.substring(1, json.length() - 1); // Remove outer { }

            // Extract fields, ignoring '$type' (if present) and 'LastModified' (which is omitted)
            final String shapeId = extractString(content, "ShapeId");
            final String typeName = extractString(content, "Type");
            final String colorHex = extractString(content, "Color");
            final double thickness = extractDouble(content, "Thickness");
            final String createdBy = extractString(content, "CreatedBy");
            final String lastModifiedBy = extractString(content, "LastModifiedBy");
            final boolean isDeleted = extractBoolean(content, "IsDeleted");
            // The timestamp is missing from the C# JSON format, so we default it to 0L during deserialization.
            // If the field was present, we would use extractLong(content, "LastModified").

            final List<Point> points = extractPoints(content);

            if (shapeId == null || typeName == null || createdBy == null || lastModifiedBy == null || points == null) {
                throw new SerializationException("Missing crucial shape field during deserialization.");
            }

            final ShapeType shapeType = ShapeType.valueOf(typeName);
            final Color color = hexToColor(colorHex);
            final ShapeId id = new ShapeId(shapeId);

            final Shape newShape;
            switch (shapeType) {
                case FREEHAND:
                    newShape = new FreehandShape(id, points, thickness, color, createdBy, lastModifiedBy);
                    break;
                case RECTANGLE:
                    newShape = new RectangleShape(id, points, thickness, color, createdBy, lastModifiedBy);
                    break;
                case TRIANGLE:
                    newShape = new TriangleShape(id, points, thickness, color, createdBy, lastModifiedBy);
                    break;
                case LINE:
                    newShape = new LineShape(id, points, thickness, color, createdBy, lastModifiedBy);
                    break;
                case ELLIPSE:
                    newShape = new EllipseShape(id, points, thickness, color, createdBy, lastModifiedBy);
                    break;
                default:
                    throw new SerializationException("Unknown ShapeType during manual parsing: " + typeName);
            }

            // Use 0L for lastModified since the value is not included in the payload.
            return new ShapeState(newShape, isDeleted, 0L);

        } catch (Exception e) {
            throw new SerializationException("Failed to manually deserialize ShapeState: " + e.getMessage(), e);
        }
    }

    private static String extractString(final String content, final String key) {
        // Pattern: "key":"value" or "key":value (if value is 'null')
        final Pattern pattern = Pattern.compile(Pattern.quote("\"" + key + "\"") + ":\"(.*?)\"");
        final Matcher matcher = pattern.matcher(content);
        return matcher.find() ? matcher.group(1) : null;
    }

    private static double extractDouble(final String content, final String key) {
        // Pattern: "key":number
        final Pattern pattern = Pattern.compile(Pattern.quote("\"" + key + "\"") + ":([\\-0-9\\.]+)");
        final Matcher matcher = pattern.matcher(content);
        return matcher.find() ? Double.parseDouble(matcher.group(1)) : 0.0;
    }

    private static boolean extractBoolean(final String content, final String key) {
        // Pattern: "key":true|false
        final Pattern pattern = Pattern.compile(Pattern.quote("\"" + key + "\"") + ":(true|false)");
        final Matcher matcher = pattern.matcher(content);
        return matcher.find() && Boolean.parseBoolean(matcher.group(1));
    }

    private static long extractLong(final String content, final String key) {
        // Pattern: "key":number
        final Pattern pattern = Pattern.compile(Pattern.quote("\"" + key + "\"") + ":(\\d+)");
        final Matcher matcher = pattern.matcher(content);
        return matcher.find() ? Long.parseLong(matcher.group(1)) : 0L;
    }

    private static List<Point> extractPoints(final String content) {
        final List<Point> points = new ArrayList<>();
        // Find content between "Points":[ and ]
        final Pattern arrayPattern = Pattern.compile(Pattern.quote("\"Points\":") + "\\[(.*?)\\]");
        final Matcher arrayMatcher = arrayPattern.matcher(content);

        if (arrayMatcher.find()) {
            final String pointsArrayContent = arrayMatcher.group(1);
            // Pattern for individual points: {"X":123.0,"Y":456.0}
            final Pattern pointPattern = Pattern.compile("\\{\"X\":([0-9\\.]+),\"Y\":([0-9\\.]+)\\}");
            final Matcher pointMatcher = pointPattern.matcher(pointsArrayContent);

            while (pointMatcher.find()) {
                final double x = Double.parseDouble(pointMatcher.group(1));
                final double y = Double.parseDouble(pointMatcher.group(2));
                points.add(new Point(x, y));
            }
        }
        return points;
    }

    // =========================================================================
    // Action Serialization/Deserialization
    // =========================================================================

    /**
     * Manually serializes an Action object, including nested ShapeState objects.
     * @param action The action to serialize.
     * @return A JSON string.
     */
    public static String serializeAction(final Action action) {
        if (action == null) {
            return "null";
        }

        final StringBuilder sb = new StringBuilder();
        sb.append("{");

        // Simple metadata fields
        sb.append(jsonEscape("ActionType")).append(":").append(jsonEscape(action.getActionType().toString())).append(",");
        sb.append(jsonEscape("ActionId")).append(":").append(jsonEscape(action.getActionId())).append(",");
        sb.append(jsonEscape("ShapeId")).append(":").append(jsonEscape(action.getShapeId().getValue())).append(",");
        sb.append(jsonEscape("UserId")).append(":").append(jsonEscape(action.getUserId())).append(",");
        sb.append(jsonEscape("Timestamp")).append(":").append(action.getTimestamp()).append(",");

        // PrevState (nested ShapeState JSON)
        final String prevStateJson = serializeShape(action.getPrevState());
        sb.append(jsonEscape("PrevState")).append(":");
        if (prevStateJson != null) {
            sb.append(prevStateJson); // Append raw JSON object
        } else {
            sb.append("null");
        }
        sb.append(",");

        // NewState (nested ShapeState JSON)
        final String newStateJson = serializeShape(action.getNewState());
        sb.append(jsonEscape("NewState")).append(":");
        if (newStateJson != null) {
            sb.append(newStateJson); // Append raw JSON object
        } else {
            sb.append("null");
        }

        sb.append("}");
        return sb.toString();
    }

    /**
     * Manually deserializes a JSON string back into a concrete Action object.
     * @param json The JSON string.
     * @return The Action object.
     */
    public static Action deserializeAction(final String json) {
        if (json == null || json.isEmpty() || "null".equals(json)) {
            return null;
        }

        // Same highly fragile parsing approach based on the exact structure output by serializeAction.
        try {
            final String content = json.substring(1, json.length() - 1); // Remove outer { }

            final String actionId = extractString(content, "ActionId");
            final String shapeId = extractString(content, "ShapeId");
            final String userId = extractString(content, "UserId");
            final ActionType actionType = ActionType.valueOf(extractString(content, "ActionType"));
            final long timestamp = extractLong(content, "Timestamp");

            // Extract nested JSON strings for PrevState and NewState
            final String prevStateJson = extractNestedJson(content, "PrevState");
            final String newStateJson = extractNestedJson(content, "NewState");

            // Deserialize nested ShapeState objects
            final ShapeState prevState = deserializeShape(prevStateJson);
            final ShapeState newState = deserializeShape(newStateJson);

            if (actionId == null || shapeId == null || userId == null || actionType == null || newState == null) {
                throw new SerializationException("Missing crucial action field during deserialization.");
            }

            final ShapeId targetId = new ShapeId(shapeId);

            // Factory logic to create the correct concrete Action subclass
            switch (actionType) {
                case CREATE:
                    return new CreateShapeAction(actionId, userId, timestamp, targetId, newState);
                case MODIFY:
                    return new ModifyShapeAction(actionId, userId, timestamp, targetId, prevState, newState);
                case DELETE:
                    return new DeleteShapeAction(actionId, userId, timestamp, targetId, prevState, newState);
                case RESURRECT:
                    return new ResurrectShapeAction(actionId, userId, timestamp, targetId, prevState, newState);
                default:
                    throw new SerializationException("Unknown action type: " + actionType);
            }

        } catch (Exception e) {
            throw new SerializationException("Failed to manually deserialize Action: " + e.getMessage(), e);
        }
    }

    /**
     * Extracts a nested JSON object string from the content.
     * Searches for "key":{...} or "key":null.
     * This method is complex as it has to handle JSON nesting manually (curly brace counting).
     */
    private static String extractNestedJson(final String content, final String key) {
        final String searchKey = "\"" + key + "\":";
        int startIndex = content.indexOf(searchKey);

        if (startIndex == -1) {
            return null;
        }

        startIndex += searchKey.length();

        // Check for 'null' value
        if (content.regionMatches(startIndex, "null", 0, 4)) {
            return "null";
        }

        // Must be an object, find start '{'
        int objectStart = content.indexOf('{', startIndex);
        if (objectStart == -1) {
            return null;
        }

        int balance = 0;
        int objectEnd = -1;

        for (int i = objectStart; i < content.length(); i++) {
            char c = content.charAt(i);
            if (c == '{') {
                balance++;
            } else if (c == '}') {
                balance--;
                if (balance == 0) {
                    objectEnd = i;
                    break;
                }
            }
        }

        if (objectEnd != -1) {
            // Return the object content including the outermost braces
            return content.substring(objectStart, objectEnd + 1);
        }

        return null;
    }

    public static String testSerializeShapeOnly(final Shape shape) {
        if (shape == null) {
            return "{}";
        }
        // Since we need ShapeState for the isDeleted flag, we mock a ShapeState for serialization.
        // We know that for a newly drawn shape, isDeleted is false and timestamp is irrelevant for the payload structure.
        final ShapeState tempState = new ShapeState(shape, false, 0L);
        return serializeShape(tempState);
    }
}